지시자
	page
	2. include
	taglib
	
2. inculude
	==> 다른 문서를 현재 파일에 포험시키는 기능을 가진 지시어
		다른 문서와 현재 문서를 하나의 문서로 만드는 기능.
		
		형식 ]
			<%@ include file="합칠파일이름" %>
			
		참고 ]
			우리가 웹 문서를 만들다보면 여러 페이지에 같은 내용이 중복되어서 들어가는 경우가 더러 있다.
			
			하지만 원칙적으로 JSP 문서가 만든 결과를 응답하기 때문에
			(요청에 대해서 하나의 응답 문서만 응답하므로)
			
			이런 불편함을 조금이나마 덜기 위한 방법으로 제시된 지시어이다.
			
		==>
			자주 사용되는 내용은 따로 만들어 놓고
			응답 문서에 따로 만들어진 파일을 합쳐서 하나의 문서로
			만드는 방법
			
		주의 ]
			이 작업은 먼저 문서들을 합치고(하나의 문서로 만들고)
			컴파일을 한다.(==> .class 파일을 만든다.)
			만약 먼저 문서들을 하나로 합쳤을 때 문제가 생기면
			(변수 등이 충돌이 나면)
			에러가 발생한다는 것을 명심하세요...!
			
			정리 ]
				include 지시자로 두개의 문서를 하나의 문서로 합쳤을 경우
				두 문서에 똑같은 이름의 변수가 만들어질 경우
				하나의 클래스로 합쳐졌을 때 이 변수들일 충돌이 날 수 있기 때문에
				주의 해야겠다.

-----------------------------------------------------------------------------------------------------------------------------------

스크립트 방식
==> JSP는 HTML 언어가 기본이 되고 필요하면 자바 언어를
	필요한 위치에 삽입하여 같이 실행하는 문서이다.
	이 처럼 다른 언어에 포함하여 처리하는 방식을
	스크립트 방식이라고 하며
	JSP 문서에 자바 코드를 삽입하는 방식은 3가지가 있다.
	
	1. 스크립트 릿 방식
		==> 일반적인 자바 코드를 포함하는 방식을 의미한다.
			이곳에 기록한 모든 내용은 service 함수 안에 포함된다.
			따라서 이곳은 결국 지역적인 역할을 한다.
			
		참고 ]
			어차피 JSP 문서는 여러 문서가 같이 실행되는 것이 아니고
			클라이언트가 요청한 문서 하나만 실행되므로
			클래스가 연결되어서 실행되는 경우는 거의 없다.
			결론적으로 main 함수만 있으면 충분하게 그 역할을 한다.
			
		참고 ]
			JSP 문서는 실행을 하면 먼저 자바 클래스로 변환하고(.java 파일로 변환)
			그것을 컴파일해서 (==> .class 파일이 탄생...)
			실행되어진다.
			이런 클래스를 우리는 서블릿 클래스라고 부른다.
			이때 이것 역시 자바의 main함수 처럼 시작 함수가(진입점함수) 존재하는데
			그 역할을 service() 함수가 담당하고 있다.
			
		형식 ]
			<%
				자바코드 작성....
			%>
			
		참고 ]
			스크립트 릿 속에 있는 내용과 HTML 코드 내용은
			같이 service 함수에 코딩이 된다.
			따라서 두가지는 혼용해서 사용할 수 있다.
			다만 자바적인 요소와 HTML적인 요소만 구분해주면 된다.
			
	2. 선언자 방식
		==> 스크립트 릿 방식에서 설명했듯이 JSP는 service() 함수 안에서
			거의 모든 것이 기술이 되고 실행이 된다.
			하지만 가끔은 전역 변수나 함수를 만드는 방식이 선언자 방식이다.
			
			결론적으로 전역 변수와 함수를 만드는 기능을 가진 스크립트 방식이다.
			(이 안에는 일반적인 명령은 사용할 수 없다.)
			
			형식 ]
				
				<%!
					변수선언
					함수제작
				%>
				
	3. 표현자 방식
		==> System.out.println() 와 같이
			자바적인 요소(변수, 함수)를 화면에 내용을 출력하기 위한 스크립트이다.
			
		형식 ]
			<%= 출력내용 %>
			
		주의사항 ]
			출력내용은 오직 한개만 출력할 수 있다.
			이것은 System.out.println() 도 마찬가지이다.
			==> 문자열 결합을 이용해서 하나의 문자열로 만들어서
				출력하는 방식을 사용해야 한다.
				
-------------------------------------------------------------------------------------------------------------------------------

참고 ]
	주석문
		1. 확장자가 html 인 문서(HTML)에서는
			<!-- -->
				의 방식으로 html 주석 처리 방식을 따른다.
		
		2. 확장자가 jsp인 문서에서는
			1) HTML 요소 부분
				<%-- --%> 의 방식으로 주석문을 달 수 있다. 화면에 보여지지 않는다.
				<!-- -->	==> 화면에 보여진다.
				
			2) 자바적인 요소 부분
				// 단일행 주석
				/* */ 다중행 주석
	
==================================================================================================================================	
	
내장객체
==> 자주 사용하는 클래스 중 몇가지는 JSP 안에서 미리 new 시켜서
	사용할 수 있도록 미리 준비해 놓은 것이 있다.
	따라서 이것은 new 시킬 필요없이 필요하면 그냥 사용되는 클래스를
	내장 객체라 부른다.
	
	1. out 객체
		==> PrintWriter 클래스를 미리 new 시켜놓은 내장객체
		
		즉
			PrintWriter out = new PrintWriter(????);
			
		이 클래스의 역할은 클라이언트에게 응답하는 문서를 작성하는 기능이다.
		
		<%= %>과 동일한 기능이다.
		
		주요함수 ]
		
			write()
			flush()
			
		PrintWriter는 jspWriter 클래스로 반환되어서 new 된 경우이다.
		
	참고 ]
		따라서 내장객체는 결국 클래스를 사용하는 것이다.
		그 클래스 안에 원하는 함수가 무었인지를 파악하는 것이 중요하다.
		
	2. request 객체
		==> 클라이언트의 요청 정보를 관리하는 역할을 하는 내장 객체이다.
			즉, 요청한 클라이언트의 IP주소, 요청내용, 부가정보를 알고 싶은 경우
			사용하는 내장객체이다.
			
		HttpSevletRequest 를 이용해서 만들어진 내장객체이다.
		
		주요함수 ]
			getParameter()
			==> 서버측에서 클라이언트가 준 부가정보(파라미터)를 알아내는 함수
			
				사용형식 ]
					
					String ??? = request.getParameter("키값");	
				
				주의사항 ]
					부가정보(파라미터)는 오직 String(문자열)으로만 받을 수 있다.
			
			getParameterValues()
				형식 ]
					String[] ??? = request.getParameterValues("키값");
					
	참고 ]
		클라이언트가 서버에게 요청하는 방법
			1. GET 방식
				1) 주소표시줄에 직접 입력해서 요청하는 방법
				
				2)
					<a> 태그를 이용해서 요청하는 방법
					
						형식 ]
							<a href="요청주소">???</a>
				
				3) javascript에서 location 객체를 사용해서 요청하는 방법
				
					형식 ]
						location.href = '??????';
						
				4) form 태그의 method 속성의 속성ㄱ밧으로 GET을 설정하고
					form태그로 요청하는 방법
					
					형식 ]
						<form method="GET action="요청주소" name="????" id="???">
						</form>
						
				참고 ]
					GET 방식으로 요청할 때 부가정보(파라미터)를 같이 줄 수 있다.
					예를 들어 게시판 목록보기를 할 때
						며쳎이지를 보여주세요...
					라고 요청할 수 있다.
					
					형식 ]
						<a herf="요청문서?키값=데이터&키값=데이터&...">내용</a>
						
						주의 ]
							?, =, & 기호 앞뒤에는 절대로 공백이 있어서는 안된다.
							
				참고 ]
					GET 방식은 요청 내용이 주소표시줄에 노출이 되기 때문에
					보안에 취약한 단점이 있다.
					
				참고 ]
					부가정보(파라미터)에 한글이 들어가면 서버측에서 받을 수 없는 경우가 있다.
					즉, 한글이 깨져서 나온다고들 한다.
					
					해결방법 ]
						1. 그 문서에서만 해결하는 방법
							<%
								request.setCharacterEncoding("UTF-8");
							%>					
							
						2. 모든 문서에서 해결하는 방법
							server.xml 파일안에서
							<Connector 태그 마지막부분에
								URIEncoding="UTF-8"
							을 추가해주면 된다.
			2. POST 방식
				1) form 태그를 제작해서 요청하는 방법
					==> 로그인 폼과 같이 사용자가 필요한 것을 입력
						또는 선택해서 서버에게 전달하는 방식
						
					특징 ]
						반드시 <form> 태그 안에 입력태그를 만들어야 한다.
						만약 어떤 입력태그가 <form> 태그안에 있지 않으면
						그 태그의 입력된 내용은 서버에 전달되지 않는다.
						
					참고 ]
						이때는 반드시 이 폼의 내용을 전달할 도구를 준비해야 한다.
						이 도구를 우리는 submit(제출) 도구라고 한다.
						
						제출도구 만드는 방법 ]
						
							1) html 로 해결하는 방법
								<input type="submit" value="버튼이름">
								==> 모양은 버튼이지만
									이 버튼을 클릭하면 폼 태그에 감싸진 모든 입력태그의 내용이
									서버에 전달이 된다.
									
							2) 자바스크립트로 해결하는 방법
								<script type="text/javascript">
									var frm = 폼태그 선택;
									
									frm.submit();
								</script>
								
			form 태그 작성 형식 ]
			
				<form method="POST" action="요청문서">
					필요한 입력태그 준비...
				</form>
				
				참고 ]
					중요속성
						method
							==> 폼의 데이터를 서버에게 보내는 방법
								GET, POST 중 하나를 선택한다.
								
						action
							==> 서버에게 요청할 문서의 주소
							
				참고 ]
					POST 방식은 스트림을 이용해서 서버에게 전달하게 되므로
					주소칸에 그 내용이 나오지 않게 된다.
					따라서 GET 방식 보다는 보안에 유리하다.(조금....)
					
				참고 ]
					POST 방식으로 전달하는 데이터의 한글 깨짐 방지 방법
					서버가 필터링을 이용해서 인코딩해줘야 한다.
					
					방법 ]
						1. 필터를 등록한다.
							web.xml 파일을 열고...
						
							<filter>
					        <filter-name>setCharacterEncodingFilter</filter-name>
					         ==> 만드는 필터의 이름
					        <filter-class>org.apache.catalina.filters.SetCharacterEncodingFilter</filter-class>
					        ==> 필터에 사용할 클래스를 지정하는 부분
					        <init-param>
					            <param-name>encoding</param-name>
					            <param-value>UTF-8</param-value>
					        </init-param>
					        
				        	부분을 찾아서 주석을 해제해준다.
					        
				        2. 필터를 적용하는 부분
				        	web.xml 파일에서...
				        	
				        		 <filter-mapping>
							        <filter-name>setCharacterEncodingFilter</filter-name>
							        <url-pattern>/*</url-pattern>
							        ==> 어떤 요청에 적용을 시킬 것인지 요청 패턴을 지정하는 부분
							        	/* 의 의미는 모든 요청에 대해서 필터를 적용시키겠다는 의미이다.
							    </filter-mapping>
						    부분을 찾아서 주석을 해제해준다.
						    
				    참고 ]
				    	<input type="text"
				    	<input type="password"
				    	<textarea></textarea>
				    	의 3가지(입력태그)는 사용자가 입력한 내용이 서버에 전달이 된다.
				    	
				    	하지만 그 이외의 태그들은 홤녀에 보이는 내용이 전달되지 않고
				    	value 속성으로 지정한 내용이 서버에 전달이 된다.
				    	결론적으로 입력태그 계열 이외의 태그를 제작할 경우에는
				    	반드시 value 속성을 지정해야 한다.
				    	
			    	참고 ]
			    		만약 같은 폼태그 안에 같은 name 속성값이 여러개 존재하는 경우에는
			    		모든 데이터가 배열형식으로 전달 되어진다.
			    		
			    		따라서 이때는
			    			request.getParameterValues();
		    			함수를 이용해서 꺼내와야 한다.
		    			
	    			참고 ]
	    				만든 폼이 라디오버튼이거나 체크상자인 경웽는
	    				선택된 내용만 서버로 전달된다.
	    				
	    				특히 체크박스의 경우 선택, 취소로 서버에 전달되지 않는다.
	    				
			3. response
				==> 서버가 클라이언트에게 응답하는 정보를 관리하는 내장객체
				
					HttpServletResponse 라는 클래스를 이용해서 만들어진 내장 객체
					
					주요함수 ]
						
						sendRedirect()
						==> 서버측에서 강제로 클라이언트의 요청을 변경하는 명령이다.
							즉, 클라이언트는 A 라는 문서를 요청했는데
							서버측에서 강제로 B 라는 문서로 응답하는 방법 
							
							예를들어 게시판 글쓰기를 요청한 경우
							이때 글쓰기 작업이 끝나면 글쓰기 작업에 대한 응답을 하는 것이 아니고
							강제로 목록보기 보여주기를 응답하는 것이 일반적이다.
							그런데 이때 목록보기도 하나의 요청에 해당한다.
							
							이처럼 서버는 가끔 필요하면
							클라이언트의 요청(예를 들어 글등록요청)을 서버가
							다른 요청으로(예를들어 목록보기 요청)으로 바꿔야 할 필요가 있다.
							
					참고 ]
						서버가 요청을 바꾸는 방법
							1. Redirect
								==> sendRedirect()
									원래 클라이언트의 요청 정보를 모두 잊어버리고
									완벽하게 새로운 요청으로 처리한다.
									
									따라서 원래 클라이언트가 준 정보는 잊어버린 상태가 된다.
									
									새로고침하면 마지막 요청(서버가 변경한 요청)부터 시작한다.
									즉, 서버가 바꿔치기한 요청부터 시작한다.
									
							2. Forward
								==> 원래 클라이언트의 요청 정보를 유지한 상태에서
									화면에 보이는 문서만 바꾸는 기법으로 처리한다.
									
									따라서 원래 클라이언트가 준 정보는 기억하고있는 상태이다.
									
									새로고침하면 처음부터 다시 시작한다.
									즉, 클라이언트의 실제 요청부터 다시 시작한다.
							
					
	
	
	
	
	
	
	
	
	
	
	
		